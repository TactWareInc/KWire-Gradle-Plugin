package net.tactware.kwire.gradle.impl


import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeName
import com.squareup.kotlinpoet.TypeSpec
import com.squareup.kotlinpoet.asTypeName
import kotlin.text.iterator

class ServiceClientGenerator {
    /** Legacy entry point (no anchor). */
    fun generate(service: ServiceInfo): String = generate(service, anchor = null)

    /** Anchor-aware entry point. */
    internal fun generate(service: ServiceInfo, anchor: ClientAnchorInfo?): String {
        val iface = ClassName(service.packageName, service.interfaceName)
        val target = if (anchor != null) {
            GenerationTarget(
                packageName = anchor.packageName,
                superType = ClassName(anchor.packageName, anchor.abstractClassName),
                returnType = iface, // factory returns interface; easy to swap to anchor base if you prefer
                clientSimpleName = "${service.interfaceName}ClientImpl",
                emitFactory = anchor.generateFactory
            )
        } else {
            GenerationTarget(
                packageName = service.packageName,
                superType = iface,
                returnType = iface,
                clientSimpleName = "${service.interfaceName}ClientImpl",
                emitFactory = true
            )
        }
        return generateIntoTarget(service, target)
    }

    // ----------------------------------------------------------------------

    private fun generateIntoTarget(service: ServiceInfo, target: GenerationTarget): String {
        val clientClassName = ClassName(target.packageName, target.clientSimpleName)

        val file = FileSpec.builder(target.packageName, target.clientSimpleName)
            .addFileComment("Generated by KWire RPC Plugin â€” DO NOT EDIT")
            // Core RPC types
            .addImport("net.tactware.kwire.core.messages", "RpcRequest", "RpcResponse", "StreamStart", "StreamData", "StreamEnd")
            .addImport("net.tactware.kwire.core", "RpcTransport")
            // JSON & time
            .addImport("kotlinx.datetime", "Clock")
            // Coroutines / Flow helpers
            .addImport("kotlinx.coroutines", "withTimeout", "CoroutineScope", "Dispatchers", "SupervisorJob", "launch")
            .addImport("kotlinx.coroutines.flow", "Flow", "MutableSharedFlow", "callbackFlow", "filterIsInstance", "first")
            .addImport("kotlinx.coroutines.channels", "awaitClose")
            // atomic delegate for stream ids
            .addImport("kotlinx.atomicfu", "atomic")
            .addType(buildClientClass(service, target, clientClassName))
            .apply {
                if (target.emitFactory) addFunction(buildFactoryFunction(service, target, clientClassName))
            }
            .build()

        return file.toString()
    }

    private fun buildClientClass(
        service: ServiceInfo,
        target: GenerationTarget,
        clientClassName: ClassName,
    ): TypeSpec {
        val ctor = FunSpec.constructorBuilder()
            .addParameter("transport", ClassName("net.tactware.kwire.core", "RpcTransport"))
            .addParameter(
                ParameterSpec.builder("json", ClassName("kotlinx.serialization.json", "Json"))
                    .defaultValue("defaultJson()")
                    .build()
            )
            .addParameter(
                ParameterSpec.builder("callTimeoutMs", Long::class)
                    .defaultValue("5_000L")
                    .build()
            )
            .build()

        val cls = TypeSpec.classBuilder(clientClassName)
            .addKdoc("Client implementation for %L (%L)", service.interfaceName, service.serviceName)
            .superclass(target.superType) // if anchor is a class, KotlinPoet will handle; otherwise it's the interface
            .primaryConstructor(ctor)
            .addProperty(PropertySpec.builder("transport", ClassName("net.tactware.kwire.core", "RpcTransport")).initializer("transport").addModifiers(KModifier.PRIVATE).build())
            .addProperty(PropertySpec.builder("json", ClassName("kotlinx.serialization.json", "Json")).initializer("json").addModifiers(KModifier.PRIVATE).build())
            .addProperty(PropertySpec.builder("callTimeoutMs", Long::class).initializer("callTimeoutMs").addModifiers(KModifier.PRIVATE).build())
            // private scope for streaming plumbing
            .addProperty(
                PropertySpec.builder("scope", ClassName("kotlinx.coroutines", "CoroutineScope"))
                    .initializer("CoroutineScope(SupervisorJob() + Dispatchers.Default)")
                    .addModifiers(KModifier.PRIVATE)
                    .build()
            )
            .addFunction(genMessageIdFn())
            .addFunction(genStreamIdFn())
            // Backing flows + atomic ids for NO-ARG streaming methods
            .apply {
                service.methods.filter { it.isStreaming && it.parameters.isEmpty() }.forEach { m ->
                    val itemType = flowInnerType(m.returnType) // e.g., List<com.pkg.User>
                    val base = methodBase(m.methodName)
                    addProperty(
                        PropertySpec.builder("_${m.methodName}", ClassName("kotlinx.coroutines.flow", "MutableSharedFlow").parameterizedBy(itemType.asTypeNameFromString()))
                            .initializer("MutableSharedFlow()")
                            .addModifiers(KModifier.PRIVATE)
                            .build()
                    )
                    addProperty(
                        PropertySpec.builder("stream${base}Id", String::class.asTypeName().copy(nullable = true))
                            .mutable(true)
                            .delegate(CodeBlock.of("atomic<String?>(null)"))
                            .addModifiers(KModifier.PRIVATE)
                            .build()
                    )
                }
            }
            // Methods
            .apply {
                service.methods.forEach { m -> addFunction(generateMethodImpl(service, m)) }
            }
            // Init block to start/stop streams on subscription changes (no-arg only)
            .addInitializerBlock(initStreamingBlock(service))
            .addType(TypeSpec.companionObjectBuilder().addFunction(defaultJsonFun()).build())
            .build()

        return cls
    }

    private fun buildFactoryFunction(
        service: ServiceInfo,
        target: GenerationTarget,
        clientClassName: ClassName,
    ): FunSpec =
        FunSpec.builder("create${target.clientSimpleName}")
            .returns(target.returnType)
            .addParameter("transport", ClassName("net.tactware.kwire.core", "RpcTransport"))
            .addParameter(
                ParameterSpec.builder("json", ClassName("kotlinx.serialization.json", "Json").copy(nullable = true))
                    .defaultValue("null")
                    .build()
            )
            .addParameter(ParameterSpec.builder("callTimeoutMs", Long::class).defaultValue("5_000L").build())
            .addCode(
                CodeBlock.of(
                    """
                    val actualJson = json ?: ${clientClassName}.defaultJson()
                    return %T(transport, actualJson, callTimeoutMs)
                    """.trimIndent(),
                    clientClassName
                )
            )
            .build()

    // ----------------------------------------------------------------------

    private fun generateMethodImpl(service: ServiceInfo, m: MethodInfo): FunSpec {
        val hasParams = m.parameters.isNotEmpty()

        return if (m.isStreaming) {
            if (!hasParams) {
                // No-arg streaming: return the backing flow
                FunSpec.builder(m.methodName)
                    .addModifiers(KModifier.OVERRIDE)
                    .returns(m.returnType.asTypeNameFromString())
                    .addCode("return _%L\n", m.methodName)
                    .build()
            } else {
                // Parameterized streaming: callbackFlow (per-call stream id)
                val varName = "stream${methodBase(m.methodName)}Id"
                FunSpec.builder(m.methodName)
                    .addModifiers(KModifier.OVERRIDE)
                    .returns(m.returnType.asTypeNameFromString())
                    .apply {
                        if (hasParams) addParameters(m.parameters.map { ParameterSpec.builder(it.name, it.type.asTypeNameFromString()).build() })
                    }
                    .addCode(
                        """
                        return callbackFlow {
                            val $varName = generateStreamId()
                            val start = StreamStart(
                                messageId = generateMessageId(),
                                timestamp = Clock.System.now().toEpochMilliseconds(),
                                streamId = $varName,
                                serviceName = %S,
                                methodId = %S,
                                parameters = listOf(${paramsEncode(m)})
                            )
                            transport.send(start)

                            val job = kotlinx.coroutines.GlobalScope.launch {
                                transport.receive().filterIsInstance<StreamData>().collect { ev ->
                                    if (ev.streamId == $varName) {
                                        val value = json.decodeFromString<%L>(ev.data.toString())
                                        trySend(value)
                                    }
                                }
                            }

                            awaitClose {
                                job.cancel()
                                transport.send(
                                    StreamEnd(
                                        messageId = generateMessageId(),
                                        timestamp = Clock.System.now().toEpochMilliseconds(),
                                        streamId = $varName
                                    )
                                )
                            }
                        }
                        """.trimIndent(),
                        service.serviceName,
                        m.rpcMethodId,
                        flowInnerType(m.returnType)
                    )
                    .build()
            }
        } else {
            // Unary (suspend) call
            FunSpec.builder(m.methodName)
                .addModifiers(KModifier.OVERRIDE, KModifier.SUSPEND)
                .returns(m.returnType.asTypeNameFromString())
                .apply { if (hasParams) addParameters(m.parameters.map { ParameterSpec.builder(it.name, it.type.asTypeNameFromString()).build() }) }
                .addCode(
                    """
                    val req = RpcRequest(
                        messageId = generateMessageId(),
                        timestamp = Clock.System.now().toEpochMilliseconds(),
                        serviceName = %S,
                        methodId = %S,
                        parameters = listOf(${paramsEncode(m)})
                    )
                    transport.send(req)

                    val resp = withTimeout(callTimeoutMs) {
                        transport.receive().filterIsInstance<RpcResponse>().first { it.messageId == req.messageId }
                    }

                    """.trimIndent(),
                    service.serviceName,
                    m.rpcMethodId

                )
                .addCode("return json.decodeFromString<%T>(resp.result.toString())", m.returnType.asTypeNameFromString())
                .build()
        }
    }

    /** init { ... } block wiring subscriptionCount to start/stop streams for NO-ARG streaming methods */
    private fun initStreamingBlock(service: ServiceInfo): CodeBlock {
        val b = CodeBlock.builder()
        val noArgStreams = service.methods.filter { it.isStreaming && it.parameters.isEmpty() }
        if (noArgStreams.isEmpty()) return b.build()


        noArgStreams.forEach { m ->
            val base = methodBase(m.methodName)
            val idVar = "stream${base}Id"
            val backing = "_${m.methodName}"
            val itemType = flowInnerType(m.returnType)
            b.add("scope.launch(Dispatchers.Default)Â·{\n").indent()
            b.add(
                """
                $backing.subscriptionCount.collect { subCount ->
                    if (subCount > 0) {
                        if ($idVar == null) {
                            val safeStreamId = generateStreamId().also { $idVar = it }
                            val start = StreamStart(
                                messageId = generateMessageId(),
                                timestamp = Clock.System.now().toEpochMilliseconds(),
                                streamId = safeStreamId,
                                serviceName = %S,
                                methodId = %S,
                                parameters = emptyList()
                            )
                            transport.send(start)

                            scope.launch {
                                transport.receive()
                                    .filterIsInstance<StreamData>()
                                    .collect { ev ->
                                        if (ev.streamId == safeStreamId) {
                                            val value = json.decodeFromString<%L>(ev.data.toString())
                                            $backing.emit(value)
                                        }
                                    }
                            }
                        }
                    } else {
                        val oldId = $idVar
                        if (oldId != null) {
                            $idVar = null
                            val stop = StreamEnd(
                                messageId = generateMessageId(),
                                timestamp = Clock.System.now().toEpochMilliseconds(),
                                streamId = oldId
                            )
                            transport.send(stop)
                        }
                    }
                }

                """.trimIndent(),
                service.serviceName,
                m.rpcMethodId,
                itemType
            )
            b.unindent().add("}\n")

        }
        return b.build()
    }

    // ----------------------------------------------------------------------

    private fun defaultJsonFun(): FunSpec =
        FunSpec.builder("defaultJson")
            .returns(ClassName("kotlinx.serialization.json", "Json"))
            .addKdoc("Default Json settings for RPC clients")
            .addCode(
                """
                return Json {
                    ignoreUnknownKeys = true
                    isLenient = true
                    encodeDefaults = true
                    prettyPrint = false
                }
                """.trimIndent()
            )
            .build()

    private fun genMessageIdFn(): FunSpec =
        FunSpec.builder("generateMessageId")
            .addModifiers(KModifier.PRIVATE)
            .returns(String::class)
            .addCode(
                """
                val ts = Clock.System.now().toEpochMilliseconds()
                val rnd = (1000..9999).random()
                return "msg_${'$'}ts${'$'}rnd"
                """.trimIndent()
            )
            .build()

    private fun genStreamIdFn(): FunSpec =
        FunSpec.builder("generateStreamId")
            .addModifiers(KModifier.PRIVATE)
            .returns(String::class)
            .addCode(
                """
                val ts = Clock.System.now().toEpochMilliseconds()
                val rnd = (1000..9999).random()
                return "stream_${'$'}ts${'$'}rnd"
                """.trimIndent()
            )
            .build()

    private fun paramsEncode(m: MethodInfo): String =
        if (m.parameters.isEmpty()) "" else m.parameters.joinToString { "json.parseToJsonElement(json.encodeToString(${it.name}))" }

    private fun methodBase(methodName: String): String =
        methodName.removePrefix("stream").replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }

    private fun flowInnerType(type: String): String =
        when {
            type.startsWith("kotlinx.coroutines.flow.Flow<") -> type.removePrefix("kotlinx.coroutines.flow.Flow<").removeSuffix(">").trim()
            type.startsWith("Flow<") -> type.removePrefix("Flow<").removeSuffix(">").trim()
            else -> type
        }
}

/* ============================ Type helpers ============================ */

private fun String.asTypeNameFromString(): TypeName {
    val isNullable = endsWith("?")
    val core = if (isNullable) dropLast(1) else this

    val lt = core.indexOf('<')
    val typeName: TypeName = if (lt >= 0 && core.endsWith(">")) {
        val base = core.substring(0, lt).trim()
        val argsBlock = core.substring(lt + 1, core.lastIndexOf('>'))
        val args = splitTopLevelCommas(argsBlock).map { it.trim().asTypeNameFromString() }
        mapBaseToClassName(base).parameterizedBy(args)
    } else {
        mapBaseToClassName(core)
    }

    return typeName.copy(nullable = isNullable)
}

private fun mapBaseToClassName(base: String): ClassName {
    if ('.' in base) return ClassName.bestGuess(base)
    return when (base) {
        // stdlib
        "Int","Long","Short","Byte","Float","Double","Boolean","Unit","String" ->
            ClassName("kotlin", base)
        // collections
        "List","Set","Map","MutableList","MutableSet","MutableMap","Collection","Iterable" ->
            ClassName("kotlin.collections", base)
        // Flow
        "Flow" -> ClassName("kotlinx.coroutines.flow", "Flow")
        else -> ClassName.bestGuess(base)
    }
}

// split generic args by commas not inside <...>
private fun splitTopLevelCommas(s: String): List<String> {
    val out = ArrayList<String>()
    val buf = StringBuilder()
    var depth = 0
    for (ch in s) {
        when (ch) {
            '<' -> { depth++; buf.append(ch) }
            '>' -> { if (depth > 0) depth--; buf.append(ch) }
            ',' -> if (depth == 0) { out += buf.toString(); buf.clear() } else buf.append(ch)
            else -> buf.append(ch)
        }
    }
    if (buf.isNotEmpty()) out += buf.toString()
    return out
}
