package net.tactware.kwire.gradle.impl

import com.squareup.kotlinpoet.ClassName
import com.squareup.kotlinpoet.CodeBlock
import com.squareup.kotlinpoet.FileSpec
import com.squareup.kotlinpoet.FunSpec
import com.squareup.kotlinpoet.KModifier
import com.squareup.kotlinpoet.ParameterSpec
import com.squareup.kotlinpoet.ParameterizedTypeName.Companion.parameterizedBy
import com.squareup.kotlinpoet.PropertySpec
import com.squareup.kotlinpoet.TypeName
import com.squareup.kotlinpoet.TypeSpec
import net.tactware.kwire.gradle.impl.ServerAnchorInfo
import kotlin.text.iterator

class ServiceServerGenerator {

    data class GenerationTarget(
        val packageName: String,
        val superType: ClassName,          // anchor abstract base (if you ever need it)
        val serverSimpleName: String,      // e.g., UserServiceServerImpl
        val emitFactory: Boolean
    )

    fun generate(service: ServiceInfo): String = generate(service, anchor = null)

    fun generate(service: ServiceInfo, anchor: ServerAnchorInfo?): String {
        val iface = ClassName(service.packageName, service.interfaceName)
        val target = if (anchor != null) {
            GenerationTarget(
                packageName = anchor.packageName,
                superType = ClassName(anchor.packageName, anchor.abstractClassName),
                serverSimpleName = "${service.interfaceName}ServerImpl",
                emitFactory = anchor.generateFactory
            )
        } else {
            GenerationTarget(
                packageName = service.packageName,
                superType = iface,
                serverSimpleName = "${service.interfaceName}ServerImpl",
                emitFactory = true
            )
        }
        return generateIntoTarget(service, target)
    }

    // ----------------------------------------------------------------------

    private fun generateIntoTarget(service: ServiceInfo, target: GenerationTarget): String {
        val serverClassName = ClassName(target.packageName, target.serverSimpleName)
        val iface = ClassName(service.packageName, service.interfaceName)

        val file = FileSpec.builder(target.packageName, target.serverSimpleName)
            .addFileComment("Generated by KWire RPC Plugin â€” DO NOT EDIT")
            // Imports (KotlinPoet will also add specific ones as needed)
            .addImport("kotlinx.coroutines", "CoroutineDispatcher", "CoroutineScope", "Dispatchers", "Job", "SupervisorJob", "cancel", "launch")
            .addImport("kotlinx.coroutines.flow", "collect")
            .addImport("kotlinx.datetime", "Clock")
            .addImport("kotlinx.serialization.json", "Json")
            .addImport("net.tactware.kwire.core", "RpcTransport")
            .addImport("net.tactware.kwire.core.messages", "RpcError", "RpcRequest", "RpcResponse", "StreamData", "StreamEnd", "StreamStart")
            .addImport("java.util.concurrent", "ConcurrentHashMap")
            // Type imports for the interface & nested API types will be handled by KotlinPoet through TypeNames
            .addType(buildServerClass(service, target, serverClassName, iface))
            .apply {
                if (target.emitFactory) addFunction(buildFactoryFunction(service, target, serverClassName, iface))
            }
            .build()

        return file.toString()
    }

    private fun buildServerClass(
        service: ServiceInfo,
        target: GenerationTarget,
        serverClassName: ClassName,
        iface: ClassName
    ): TypeSpec {
        val ctor = FunSpec.constructorBuilder()
            .addParameter("transport", ClassName("net.tactware.kwire.core", "RpcTransport"))
            .addParameter("implementation", iface)
            .addParameter(
                ParameterSpec.builder("json", ClassName("kotlinx.serialization.json", "Json"))
                    .defaultValue("defaultJson()")
                    .build()
            )
            .addParameter(
                ParameterSpec.builder("dispatcher", ClassName("kotlinx.coroutines", "CoroutineDispatcher"))
                    .defaultValue("Dispatchers.Default")
                    .build()
            )
            .build()

        return TypeSpec.classBuilder(serverClassName)
            .addKdoc("Server shim for %L (%L). Wires RpcTransport <-> implementation.", service.interfaceName, service.serviceName)
            .addModifiers(KModifier.PUBLIC)
            .primaryConstructor(ctor)
            .superclass(target.superType)
            .addSuperclassConstructorParameter("implementation")
            .addProperty(
                PropertySpec.builder("transport", ClassName("net.tactware.kwire.core", "RpcTransport"))
                    .initializer("transport")
                    .addModifiers(KModifier.PRIVATE)
                    .build()
            )
            .addProperty(
                PropertySpec.builder("implementation", iface)
                    .initializer("implementation")
                    .addModifiers(KModifier.PRIVATE)
                    .build()
            )
            .addProperty(
                PropertySpec.builder("json", ClassName("kotlinx.serialization.json", "Json"))
                    .initializer("json")
                    .addModifiers(KModifier.PRIVATE)
                    .build()
            )
            .addProperty(
                PropertySpec.builder("scope", ClassName("kotlinx.coroutines", "CoroutineScope"))
                    .initializer("CoroutineScope(SupervisorJob() + dispatcher)")
                    .addModifiers(KModifier.PRIVATE)
                    .build()
            )
            .addProperty(
                PropertySpec.builder(
                    "streamJobs",
                    ClassName("java.util.concurrent", "ConcurrentHashMap")
                        .parameterizedBy(ClassName("kotlin", "String"), ClassName("kotlinx.coroutines", "Job"))
                )
                    .initializer("ConcurrentHashMap()")
                    .addModifiers(KModifier.PRIVATE)
                    .build()
            )
            .addFunction(startFn())
            .addFunction(stopFn())
            .addFunction(handleUnaryFn(service))
            .addFunction(handleStreamStartFn(service))
            .addFunction(handleStreamEndFn())
            .addType(companionJson())
            .build()
    }

    private fun startFn(): FunSpec =
        FunSpec.builder("start")
            .addModifiers(KModifier.PUBLIC)
            .addCode(
                """
                scope.launch {
                    transport.receive().collect { msg ->
                        when (msg) {
                            is RpcRequest  -> handleUnary(msg)
                            is StreamStart -> handleStreamStart(msg)
                            is StreamEnd   -> handleStreamEnd(msg)
                            else -> {}
                        }
                    }
                }
                """.trimIndent()
            )
            .build()

    private fun stopFn(): FunSpec =
        FunSpec.builder("stop")
            .addModifiers(KModifier.PUBLIC)
            .addCode(
                """
                scope.cancel()
                streamJobs.values.forEach { it.cancel() }
                streamJobs.clear()
                """.trimIndent()
            )
            .build()

    /**
     * private fun handleUnary(req: RpcRequest): Job = scope.launch { try { when (...) { ... send RpcResponse } else -> send RpcError } catch { send RpcResponse error-json } }
     */
    private fun handleUnaryFn(service: ServiceInfo): FunSpec {
        val b = CodeBlock.builder()
        b.add(
            """
            return scope.launch {
                try {
                    when (req.methodId) {
            """.trimIndent()
        ).add("\n")

        service.methods.filter { !it.isStreaming }.forEach { m ->
            b.add("                        %S -> {\n", m.rpcMethodId)
            // decode parameters
            m.parameters.forEachIndexed { idx, p ->
                b.addStatement(
                    "                            val %L: %T = json.decodeFromString(req.parameters[%L].toString())",
                    p.name, p.type.asTypeNameFromString(), idx
                )
            }
            val args = m.parameters.joinToString { it.name }

            // call implementation & send RpcResponse
            if (m.returnType == "Unit" || m.returnType == "kotlin.Unit") {
                b.addStatement("                            implementation.%L(%L)", m.methodName, args)
                b.addStatement(
                    """
                    |                            val resp = RpcResponse(
                    |                                messageId = req.messageId,
                    |                                timestamp = Clock.System.now().toEpochMilliseconds(),
                    |                                result = json.parseToJsonElement(%S)
                    |                            )
                    |                            transport.send(resp)
                    """.trimMargin(),
                    "null"
                )
            } else {
                b.addStatement(
                    "                            val out: %T = implementation.%L(%L)",
                    m.returnType.asTypeNameFromString(), m.methodName, args
                )
                b.addStatement(
                    """
                    |                            val resp = RpcResponse(
                    |                                messageId = req.messageId,
                    |                                timestamp = Clock.System.now().toEpochMilliseconds(),
                    |                                result = json.parseToJsonElement(json.encodeToString(out))
                    |                            )
                    |                            transport.send(resp)
                    """.trimMargin()
                )
            }
            b.add("                        }\n")
        }

        // else -> RpcError message
        b.add(
            """
                        else ->  {
                            val resp = RpcError(
                                messageId = req.messageId,
                                timestamp = Clock.System.now().toEpochMilliseconds(),
                                errorCode = %S,
                                errorMessage = %S
                            )
                            transport.send(resp)
                        }
            """.trimIndent(),
            "UnknownMethod",
            """Unknown methodId: ${'$'}{req.methodId}"""
        ).add("\n")

        // catch -> RpcResponse with inline error json (matches your sample)
        b.add(
            """
                    }
                } catch (t: Throwable) {
                    val resp = RpcResponse(
                        messageId = req.messageId,
                        timestamp = Clock.System.now().toEpochMilliseconds(),
                        result = json.parseToJsonElement(%S)
                    )
                    transport.send(resp)
                }
            }
            """.trimIndent(),
            """{"error":"${'$'}{t.message}"}"""
        )

        return FunSpec.builder("handleUnary")
            .addModifiers(KModifier.PRIVATE)
            .addParameter("req", ClassName("net.tactware.kwire.core.messages", "RpcRequest"))
            .returns(ClassName("kotlinx.coroutines", "Job"))
            .addCode(b.build())
            .build()
    }

    /**
     * private fun handleStreamStart(start: StreamStart) { ... }
     * Decodes parameters (if any) and collects the flow, echoing StreamData.
     */
    private fun handleStreamStartFn(service: ServiceInfo): FunSpec {
        val b = CodeBlock.builder()
        b.add(
            """
            if (streamJobs.containsKey(start.streamId)) return
            val job = scope.launch {
                try {
                    when (start.methodId) {
            """.trimIndent()
        ).add("\n")

        service.methods.filter { it.isStreaming }.forEach { m ->
            b.add("                        %S -> {\n", m.rpcMethodId)

            // decode parameters for streaming method, if any
            m.parameters.forEachIndexed { idx, p ->
                b.addStatement(
                    "                            val %L: %T = json.decodeFromString(start.parameters[%L].toString())",
                    p.name, p.type.asTypeNameFromString(), idx
                )
            }
            val args = m.parameters.joinToString { it.name }

            b.add(
                """
                            implementation.%L(%L).collect { item ->
                                val data = StreamData(
                                    messageId = generateMessageId(),
                                    timestamp = Clock.System.now().toEpochMilliseconds(),
                                    streamId = start.streamId,
                                    data = json.parseToJsonElement(json.encodeToString(item))
                                )
                                transport.send(data)
                            }
                """.trimIndent(), m.methodName, args
            )
            b.add("\n                        }\n")
        }

        b.add(
            """
                        else -> {}
                    }
                } finally {
                    streamJobs.remove(start.streamId)
                }
            }
            streamJobs[start.streamId] = job
            """.trimIndent()
        )

        return FunSpec.builder("handleStreamStart")
            .addModifiers(KModifier.PRIVATE)
            .addParameter("start", ClassName("net.tactware.kwire.core.messages", "StreamStart"))
            .addCode(b.build())
            .build()
    }

    private fun handleStreamEndFn(): FunSpec =
        FunSpec.builder("handleStreamEnd")
            .addModifiers(KModifier.PRIVATE)
            .addParameter("end", ClassName("net.tactware.kwire.core.messages", "StreamEnd"))
            .addCode("streamJobs.remove(end.streamId)?.cancel()\n")
            .build()

    private fun companionJson(): TypeSpec =
        TypeSpec.companionObjectBuilder()
            .addModifiers(KModifier.PUBLIC)
            .addFunction(
                FunSpec.builder("defaultJson")
                    .addModifiers(KModifier.PUBLIC)
                    .returns(ClassName("kotlinx.serialization.json", "Json"))
                    .addCode(
                        """
                        return Json {
                            ignoreUnknownKeys = true
                            isLenient = true
                            encodeDefaults = true
                            prettyPrint = false
                        }
                        """.trimIndent()
                    )
                    .build()
            )
            .addFunction(
                FunSpec.builder("generateMessageId")
                    .addModifiers(KModifier.PUBLIC)
                    .returns(String::class)
                    .addCode(
                        """
                        val ts = Clock.System.now().toEpochMilliseconds()
                        val rnd = (1000..9999).random()
                        return "msg_${'$'}ts${'$'}rnd"
                        """.trimIndent()
                    )
                    .build()
            )
            .build()

    // ----------------------------------------------------------------------

    private fun buildFactoryFunction(
        service: ServiceInfo,
        target: GenerationTarget,
        serverClassName: ClassName,
        iface: ClassName
    ): FunSpec =
        FunSpec.builder("create${target.serverSimpleName}")
            .addModifiers(KModifier.PUBLIC)
            .returns(serverClassName)
            .addParameter("transport", ClassName("net.tactware.kwire.core", "RpcTransport"))
            .addParameter("implementation", iface)
            .addParameter(
                ParameterSpec.builder("json", ClassName("kotlinx.serialization.json", "Json").copy(nullable = true))
                    .defaultValue("null")
                    .build()
            )
            .addParameter(
                ParameterSpec.builder("dispatcher", ClassName("kotlinx.coroutines", "CoroutineDispatcher").copy(nullable = true))
                    .defaultValue("null")
                    .build()
            )
            .addCode(
                """
                val actualJson = json ?: %T.defaultJson()
                val actualDispatcher = dispatcher ?: Dispatchers.Default
                return %T(transport, implementation, actualJson, actualDispatcher)
                """.trimIndent(),
                serverClassName, serverClassName
            )
            .build()
}

/* ============================ Type helpers ============================ */

private fun String.asTypeNameFromString(): TypeName {
    val isNullable = endsWith("?")
    val core = if (isNullable) dropLast(1) else this

    val lt = core.indexOf('<')
    val typeName: TypeName = if (lt >= 0 && core.endsWith(">")) {
        val base = core.substring(0, lt).trim()
        val argsBlock = core.substring(lt + 1, core.lastIndexOf('>'))
        val args = splitTopLevelCommas(argsBlock).map { it.trim().asTypeNameFromString() }
        mapBaseToClassName(base).parameterizedBy(args)
    } else {
        mapBaseToClassName(core)
    }

    return typeName.copy(nullable = isNullable)
}

private fun mapBaseToClassName(base: String): ClassName {
    if ('.' in base) return ClassName.bestGuess(base)
    return when (base) {
        // kotlin stdlib
        "Int","Long","Short","Byte","Float","Double","Boolean","Unit","String" ->
            ClassName("kotlin", base)
        // collections
        "List","Set","Map","MutableList","MutableSet","MutableMap","Collection","Iterable" ->
            ClassName("kotlin.collections", base)
        // Flow
        "Flow" -> ClassName("kotlinx.coroutines.flow", "Flow")
        else -> ClassName.bestGuess(base)
    }
}

private fun splitTopLevelCommas(s: String): List<String> {
    val out = ArrayList<String>()
    val buf = StringBuilder()
    var depth = 0
    for (ch in s) {
        when (ch) {
            '<' -> { depth++; buf.append(ch) }
            '>' -> { if (depth > 0) depth--; buf.append(ch) }
            ',' -> if (depth == 0) { out += buf.toString(); buf.clear() } else buf.append(ch)
            else -> buf.append(ch)
        }
    }
    if (buf.isNotEmpty()) out += buf.toString()
    return out
}
